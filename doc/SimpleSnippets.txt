*SimpleSnippets.txt*    For Vim 8.0 and NeoVim 0.3.0 or later.

Simple Snippets Plugin for Vim and NeoVim~

SimpleSnippets                                   *snippet* *snippets* *SimpleSnippets*

1. Description                                   |SimpleSnippets-description|
   1.1 Requirements                              |SimpleSnippets-requirements|
   1.2 Limitations                               |SimpleSnippets-limitations|
   1.3 Acknowledgments                           |SimpleSnippets-acknowledgments|
2. Installation and Updating                     |SimpleSnippets-installnupdate|
3. Settings & Commands                           |SimpleSnippets-settings|
   3.1 Settings                                  |SimpleSnippets-settings|
   3.2 Commands                                  |SimpleSnippets-commands|
   3.3 Mappings                                  |SimpleSnippets-mappings|
   3.3 Snippet Search Path                       |SimpleSnippets-snippet-search-path|
   3.5 Functions                                 |SimpleSnippets-functions|
     3.5.1 SimpleSnippets#isExpandableOrJumpable |SimpleSnippets#isExpandableOrJumpable|
     3.5.2 SimpleSnippets#expandOrJump           |SimpleSnippets#expandOrJump|
     3.5.3 SimpleSnippets#expand                 |SimpleSnippets#expand|
     3.5.4 SimpleSnippets#jump                   |SimpleSnippets#jump|
     3.5.5 SimpleSnippets#jumpToLastPlaceholder  |SimpleSnippets#jumpToLastPlaceholder|
     3.5.6 SimpleSnippets#addFlashSnippet        |SimpleSnippets#addFlashSnippet|
4. Syntax                                        |SimpleSnippets-syntax|
   4.1 Adding Snippets                           |SimpleSnippets-adding-snippets|
     4.1.1 Flash Snippets                        |SimpleSnippets-flash-snippets|
   4.2 Placeholder Syntax                        |SimpleSnippets-placeholder-syntax|
     4.2.1 Normal Placeholders                   |SimpleSnippets-normal-placeholder|
     4.2.2 Mirror Placeholders                   |SimpleSnippets-mirror-placeholder|
     4.2.3 Shell Placeholders                    |SimpleSnippets-shell-placeholder|
   4.3 Snippets Examples                         |SimpleSnippets-snippet-examples|
5. Contributing                                  |SimpleSnippets-contributing|


================================================================================
1. Description                                        *SimpleSnippets-description*

SimpleSnippets provides a simple support of snippets to Vim and NeoVim.
This plugin doesn't have any advantages over other snippet solutions, like Ultisnips,
SnipMate, Neosnippets, and maybe others. The main reasons I've wrote this,
because, I needed fast and simple plugin that let me define all my actions via single
<Tab> key, and won't struggle on weak devices.

                                                     *SimpleSnippets-requirements*
1.1 Requirements
----------------

This plugin is tested against Vim 8.0 and NeoVim 0.3.0. All other versions are
unsupported, but might work too. This plugin works only in 'nocompatible' mode.

                                                      *SimpleSnippets-limitations*
1.2 Limitations
---------------

This plugin has some limitations, which may make you decide not to use this
plugin at all. I've developed this plugin to be as simple as possible, to use it
on smartphone, and weak devices, like netbooks, which I still use during trips.

  1. This plugin doesn't support empty placeholders, i.e. tabstops - `$1`, `$2`, etc.
  You can't use them, instead please use normal placeholders, see
  |SimpleSnippets-normal-placeholders|.

  2. You can't have several placeholders with same contents like so:

    `typedef struct ${1:Name} {`
    `    ${0:Name};`
    `} ${2:Name};`

  Jump order will be broken, because SimpleSnippets jumps on the text, stored in
  special list.

  3. You can't have the same text in mirrored placeholder, and normal placeholder
  simultaneously:

    `typedef struct ${1|Name} {`
    `    ${0:Name};`
    `} Name;`

  `Name` will be replaced in zero placeholder too, which will make it unjumpable.
  Please see |SimpleSnippets-mirror-placeholders|.

  4. This plugin doesn't integrate with completion managers. So you will not see
  any suggestions of triggers in completion popup.

If You still want to use this Plugin, you're welcome to read this document, to
the end, to find out placeholder syntax, mappings, functions and other useful
info.

                                                  *SimpleSnippets-acknowledgments*
1.3 Acknowledgments
-------------------

SimpleSnippets was inspired by the snippets feature of Ultisnips plugin
(https://github.com/SirVer/ultisnips), the great snippet manager plugin by
@SirVer. I highly recommend to try it out, as I think that this is one of the
most advanced solutions for snippets in Vim.

This document is written with the look on the UltiSnips documentation which I
found as a great example of comprehensive documentation to the plugin.

================================================================================
2. Installation and Updating                       *SimpleSnippets-installnupdate*

Recommended way to install SimpleSnippets is to use plugin manager, such as
Vundle, Pathogen, dein.nvim or others. You can still install it manually by
cloning master branch from github. Assuming you're using Vundle add this line
to your configuration file:

  `Plugin 'andreyorst/simple-snippets.vim'`

SimpleSnippets comes without snippets. There are no default snippets, for now,
you should define them by yourselves. I'm planning on creating a separate plugin
with snippets.


================================================================================
3. Settings & Commands                                   *SimpleSnippets-settings*

3.1 Settings
------------

SimpleSnippets has the only setting, and it is a snippet search path. You can
define it by setting g:SimpleSnippets_search_path in your configuration file.
The default value is `$HOME.'/.vim/snippets'` but you're free to redefine it to
any other absolute path. Be sure to use absolute path, because plugin doesn't
expand paths automatically.

`g:SimpleSnippets_search_path`    Defines a directory where snippets are stored.

The other setting if to disable default mappings. We will talk about it in
|SimpleSnippets-mappings| section.

                                                         *SimpleSnippets-commands*
3.2 Commands
------------
                                                             *:SimpleSnippetsEdit*
  3.2.1 SimpleSnippetsEdit

  The `:SimpleSnippetsEdit` command asks you to input a trigger. Then it searches
  for existing snippet for this filetype and opens a vertical split with it. If
  snippet isn't found, it creates new one with proposed trigger, and opens
  vertical split. You can define snippet's body there. Upon save the snippet is
  ready for use. No need to reload the editor.

                                                         *SimpleSnippets-mappings*
3.2 Mappings
------------

By default Simple snippets remaps <Tab> key to expand snippets and jump
between placeholders. If you're using any completion manager, like Deoplete,
or nvim-completion-manager, you probably would like to disable automatic
remapping. You can disable it by defining this variable in your vimrc, or
init.vim:

  `let g:SimpleSnippets_dont_remap_tab = 1`             Disables standard mappings

Again, if you're using completion managers, that occupy <Tab> and <S-Tab>
keys, you can still have expanding and jumping via <Tab> key, but it is bit
tricky. You need to define your custom mappings in your vimrc or init.vim like
so:

  `let g:SimpleSnippets_dont_remap_tab = 1`
  `inoremap <silent><expr><Tab> pumvisible() ? "\<c-n>" : SimpleSnippets#isExpandableOrJumpable() ? "<Esc>:call SimpleSnippets#expandOrJump()<Cr>" : "\<Tab>"`
  `inoremap <silent><expr><S-Tab> pumvisible() ? "\<c-p>" : SimpleSnippets#isJumpable() ? "<Esc>:call SimpleSnippets#jumpToLastPlaceholder()<Cr>" : "\<S-Tab>"`
  `inoremap <silent><expr><Cr> pumvisible() ? SimpleSnippets#isExpandableOrJumpable() ? "\<Esc>:call SimpleSnippets#expandOrJump()\<Cr>" : "\<Cr>" : "\<Cr>"`
  `snoremap <silent><expr><Tab> SimpleSnippets#isExpandableOrJumpable() ? "<Esc>:call SimpleSnippets#expandOrJump()<Cr>" : "\<Tab>"`
  `snoremap <silent><expr><S-Tab> SimpleSnippets#isJumpable() ? "<Esc>:call SimpleSnippets#jumpToLastPlaceholder()<Cr>" : "\<S-Tab>"`

This is bit tricky, but you can still scroll through your completion popup
contents with <Tab> key, and expand snippet or jump with <Cr> key while
completion popup is visible. Thats involves second key that is needed to use
SimpleSnippets, but there is no easy way to scroll through completions and
expand with single key.

SimpleSnippets also remaps Tab in command mode. It is done to jump out of
mirrored placeholder. You can read more about mirrored placeholders at
|SimpleSnippets-mirrored-placeholder|.

                                              *SimpleSnippets-snippet-search-path*
3.3 Snippet Search Path
-----------------------

By default SimpleSnippets stores snippet files at `$HOME/.vim/snippets/`. You
can change this by defining a variable `g:SimpleSnippets_search_path` in your
vimrc or init.vim configuration file. This variable accepts string, which must be
absolute path to the directory where you want to store your snippets. For
example, if you want to store your snippets inside your project, you can define
a search path in your configuration file like so:

  `let g:SimpleSnippets_search_path = $HOME.'MyAvesomeProject/.snippets'`

SimpleSnippets snippet definition files are stored in many directories. Each
filetype usually requires it's own snippets, so snippets are stored per
filetype. So by extending the previous example, snippets for current filetype
will be stored at:

  `$HOME.'/MyAvesomeProject/.snippets/filetype'`

So for example C++ snippets will be stored inside `cpp` folder:

  `$HOME.'/MyAvesomeProject/.snippets/cpp'`

And Ruby snippets will be stored at `ruby` folder:

  `$HOME.'/MyAvesomeProject/.snippets/ruby'`

And so on. Some filetypes are quite the same, and for example `tex` and
`plaintex` both will be stored at `tex` folder. If you found that logically
similar filetypes are stored in separate folders, please open an issue at github
repo of this plugin describing which filetypes should be the same to the plugin.

                                                        *SimpleSnippets-functions*
3.5 Functions
-------------

SimpleSnippets provides some functions to use in mappings, or custom user
VimL functions. It is highly recommended to use these one, because others are
closely rely on each other and may not work separately.


                                           *SimpleSnippets#isExpandableOrJumpable*
  3.5.1 SimpleSnippets#isExpandableOrJumpable

  The first function is SimpleSnippets#isExpandableOrJumpable. It looks for
  current word under cursor, and searches for it under snippet directories. If
  snippet is found it returns 1. You can use it at <expr> mappings with your
  expand or jump key.

                                                     *SimpleSnippets#expandOrJump*
  3.5.2 SimpleSnippets#expandOrJump

  Another function to use in the mappings. You can use single key both to expand
  or jump to next placeholder. It looks to the word under the cursor to match
  any trigger, and expands it on success find. If item under cursor is not a
  trigger, it checks the state of the snippet editing process, and if it is
  active, it calls a jump function.

                                                           *SimpleSnippets#expand*
  3.5.3 SimpleSnippets#expand

  This function acts in the same way as previous function in terms of expanding
  a snippet. Can be used to define a key to expand only action.

                                                             *SimpleSnippets#jump*
  3.5.4 SimpleSnippets#jump

  This function also acts the same way as expandOrJump functions in terms of
  jumping. Can be used to define a key to jump only action.

                                            *SimpleSnippets#jumpToLastPlaceholder*
  3.5.5 SimpleSnippets#jumpToLastPlaceholder

  Yet again, this function acts the same way as previous function, except that it
  jumps directly to last placeholder. You can use it in mappings, to skip snippet
  editing process if you're happy with standard placeholder's contents.

                                            *SimpleSnippets#addFlashSnippet*
  3.5.6 SimpleSnippets#addFlashSnippet

  This function is used to communicate with SimpleSnippets from other plugins.
  You may call this function to define a snippet, that is not stored for
  further usage after exiting Vim or NeoVim. This function saves snippet's
  definition, snippet's trigger, and snippet's line count. The usage is:

    `call SimpleSnippets#addFlashSnippet('trigger', 'snippet body', line_count)`

  Which for example can be used to define function snippet, for parameter
  expansion. For example, imagine we're editing such file:

    `struct Toy {`
    `    char* name;`
    `    char* manufacturer`
    `};`

    `void print_struct_contents(struct Toy* toy)`
    `{`
    `    printf("Name: %s", toy->name);`
    `    printf("Manufacturer: %s", toy->manufacturer);`
    `}`

    `int main()`
    `{`
    `    Struct Toy* buzz_lightyear = malloc(sizeof(Toy));`
        `buzz_lightyear->name = "Buzz Lightyear";`
        `buzz_lightyear->manufacturer = "USA";`
    `    |`
    `}`

  Where `|` is your cursor position. And you want to use `print_struct_contents()`
  function here. Your semantic completion plugin may know that this is a function,
  and it has single parameter. So it can call `SimpleSnippets#addFlashSnippet()`
  function, to store this C function as a snippet:

    `call SimpleSnippets#addFlashSnippet('print_struct_contents', 'print_struct_contents(${0:toy})', 1)`

  So when user will `input print_struct_contents|` and hit his expand key, the
  result will be expanded flash snippet, wich will look like so:

    `int main()`
    `{`
    `    Struct Toy* buzz_lightyear = malloc(sizeof(Toy));`
        `buzz_lightyear->name = "Buzz Lightyear";`
        `buzz_lightyear->manufacturer = "USA";`
        `print_struct_contents([toy])`
    `}`

  Where `[toy]` means visually selected placeholder, that user can replace
  with `buzz_lightyear` right away.

================================================================================
4. Syntax                                                  *SimpleSnippets-syntax*

In this section will be described how to write your snippets.

                                                  *SimpleSnippets-adding-snippets*
4.1 Adding Snippets
-------------------

See |:SimpleSnippetsEdit| for explanations of how to define a trigger for a
snippet and |SimpleSnippets-snippet-search-path| for an explanation of where
directories with snippet definitions should be located.

As described above SimpleSnippets stores it's snippets one snippet per file at
g:SimpleSnippets_search_path in directories named accordingly to filetypes.

    Snippet location and filename    filetype ~
    ruby/trigger_name                ruby
    perl/trigger_name                perl
    c/trigger_name                   c
    cpp/trigger_name                 cpp
    all/trigger_name                 all

Folder named `all` is used to store snippets that are available from every
filetype. The mechanics work like so: SimpleSnippets searches for trigger in
current filetype folder. If trigger can't be found, SimpleSnippets looks at
`all` folder. If trigger can't be found either, the rest will rely on your
mappings. For example, if you're using <Tab> key for expanding, `tab`
character will be inserted.

                                                  *SimpleSnippets-flash-snippets*
  4.1.1 Flash Snippets

  This plugin has a feature called Flash Snippets. Snippets called 'flash' are
  filetype independent, and can be defined on the fly. It can be used by
  completion plugins, or language servers to communicate with SimpleSnippets.
  Other plugins may call a function `SimpleSnippets#addFlashSnippet()` which
  stores snippet inside script list variable. When user presses his trigger
  button, the mechanics are:

    1. Search for trigger under `g:SimpleSnippets_search_path` for current
    filetype.
    2. Search for trigger in flash snippets array.
    3. Search for trigger in `all` filetype.

  So is snippet is found, and it's filetype is 'flash snippet' (SimpleSnippets
  uses the same mechanism as for filetype wrapping here). It is expanded as
  flash snippet. For more information see |SimpleSnippets#addFlashSnippet|.

                                               *SimpleSnippets-placeholder-syntax*
4.2 Placeholder Syntax
------------------

This plugin is slightly different in terms of snippet syntax. For example it
provides three different placeholder syntaxes, and each acts differently.

Supported placeholders are:

    Placeholder type             Description ~
    `${1:Normal}`                  Normal placeholder. Its contents are selected
                                 when jumped to it. You can redefine it's body
                                 and jump to the next placeholder with your
                                 mapping.

    `${1|Mirrored}`                Mirrored placeholder. Upon jump to this
                                 placeholder all occurrences of it's bode are
                                 selected within snippet's body, and user
                                 proposed to change the text to desired one.
                                 Then text is applied to every occurrence inside
                                 placeholder's body, and automatic jump is
                                 invoked.

    `${1!Shell}`                   Shell command placeholder. When snippet body
                                 is parsed upon expanding, its body is executed
                                 as a shell command. Then the result is pasted
                                 inside snippet's body.

Each placeholder will be described later in this document.

The snippets file syntax is simple. Snippet begins at the first line of the
file, and ends with the last text line in the file. It can contain or not
contain paceholders at all. Placoholders must contain jump order definition,
which can be set from 1 to n. 0 jump definition (let's call it Zero Placeholder)
is used for last placeholder in the snippet. If your snippet contains only one
placeholder it must be Zero placeholder, and if your snippet contains multiple
placeholders, it must contain Zero placeholder, because it is used to end
snippet editing process, and to jump skip all other placeholders.

In further sections snippet examples will be provided. The only thing that
should be contained inside snippet file is the snippet's body. No `startsnippet`
or `endsnippet` entries are necessary.

                                               *SimpleSnippets-normal-placeholder*
  4.2.1 Normal Placeholders

  Normal placeholder contains text entry that will be placed in your expanded
  snippet body. You can jump onto it, and change to another. For example:

    `if (${1:true}) {`
    `    ${0:/* expression */}`
    `}`

  So if you're editing .c file and on some line you will type `if` and then hit your
  expand key, SimpleSnippets will look in defined snippet search path for `c`
  folder, and expand `if`'s contents at your current position in document, and
  then will jump automatically to first placeholder, which in this case is
  `true`. It will be selected in visual select mode, so you can edit this text,
  and then press your jump key to jump to the next placeholder, which in this case
  is `/* expression */`, which once again will be selected for you. As it is the
  last placeholder in this snippet, SimpleSnippets will change it's state to
  idle, and your jump mappings will not work until you expand another snippet.

                                               *SimpleSnippets-mirror-placeholder*
  4.2.2 Mirror Placeholders

  The implementation of mirrored placeholders in this plugin is very different,
  form other snippet plugins. Mirrored placeholder's text is applied across
  whole snippet's body. Thats is, you can define any text, and upon jump to the
  mirrored placeholder you will be prompted to enter text which you would like to
  use in snippet's body. For example:

    `class ${1|Name} {`
    `public:`
    `    Name();`
    `    virtual ~Name();`

    `private:`
    `    ${0:/* data */}`
    `};`

  The first action of every expand of any snippet is jump. In this case the
  placeholder, which is being jumped is mirrored type. Which means that we will be
  prompted to change `Name` to some other text, which suits current situation.
  `Name` will be selected across whole snippet, and you will see such message in
  the command line:

    `Replace placeholder "Name" with: |`

  Where `|` is your current cursor position. You can enter a desired name for a
  class here, and hit <Tab> or <Cr> to apply, or hit <Esc> to cancel renaming,
  which can be useful, when you're expanding a snippet and you're happy with default
  placeholder's contents. If no text entered, and <Cr> key is pressed it acts
  the same way if you would hit <Esc>. Mirrored placeholders are automatically
  executing next jump for you.

  Some note about mirroring in other plugins. ~

  I kinda like and in the same way dislike how mirrored snippet are done in
  various plugins. The main difference here, that for example in UltiSnips the
  syntax for mirroring is done by definition several placeholders with same jump
  index. For example look at the syntax of `typedef struct` snippet which I use in
  UltiSnips when writing in C at work:

    `snippet tstr "typedef struct"`
    `typedef struct ${1:Name} {`
    `    $2`
    `} $1; $0`
    `endsnippet`

  * This syntax is illegal in SimpleSnippets.~

  At some point it is good, because you're editing it in real-time, and `$1`
  placeholder is mirrored as you type, so you can see how it will affect
  snippet's body. In most cases it is better approach, and I highly recommend it
  as a default one. But in my case it was slowdown of my workflow because of weak
  hardware, so I've decided to change it to substitution-like method.

                                                *SimpleSnippets-shell-placeholder*
  4.2.3 Shell Placeholders

  The implementation of shell placeholders relies on Vim's `system()` function.
  Shell placeholders executes their contents as a command *which can be jumped
  later, and yank it to your file via `@s` register.

  * Commands that resulting to more then single line of text are currently broke
  jumping. You can jump tho the next placeholder still, but don't rely on
  jumping to, for example, `cat /usr/share/licenses/clang/LICENSE` output. It is
  will still be expanded, but one jump will be missed. For example here is the
  `uname` snippet:

  `My current Linux Kernel is:`
  `${0!uname --operating-system --kernel-release}`

  Which will be expanded to:

  `My current Linux Kernel is:`
  `4.15.15-1-ARCH GNU/Linux`

                                                 *SimpleSnippets-snippet-examples*
4.3 Snippet Examples

Here are some snippets to start with:

"for" snippet for C/C++ language:

  `for (${6:int} ${2|i} = ${3:0}; i ${4:<} ${1:10}; i${5:++}) {`
  `	${0:/* expression */}`
  `}`

"for each" snippet for C++ language:

  `for (${3:auto} ${2:i} : ${1:container}) {`
  `	${0:/* expression */}`
  `}`

"class" snippet for C++ language:

  `class ${1|Name} {`
  `public:`
  `	Name();`
  `	virtual ~Name();`

  `private:`
  `	${0:/* data */}`
  `};`

"date" snippet for all filetypes:

  `${0:Today is} ${1!date}`

================================================================================
5. Contributing                                      *SimpleSnippets-contributing*

SimpleSnippets is small plugin developed for personal usage. If you found a bug,
or want to implement a new feature or simplify/extend an existing one, feel free
to send pull requests to SimpleSnippets GitHub repository.

You can contribute by fixing or reporting bugs in our issue tracker:
https://github.com/andreyorst/simple-snippets.vim/issues

vim:tw=80:ts=8:ft=help:norl:

